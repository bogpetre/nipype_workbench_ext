from nipype.interfaces.workbench import base as wb
from nipype.interfaces.base import (
    BaseInterface, 
    BaseInterfaceInputSpec, 
    traits, 
    File, 
    Str,
    isdefined, 
    TraitedSpec, 
    CommandLineInputSpec
)
from traits.api import List
        

# parts copied from nipreps
class MetricDilateInputSpec(CommandLineInputSpec):
    metric=File(
        argstr='%s ',
        position=0,
        exists=True,
        mandatory=True,
        desc="The metric to dilate"
    )
    surface=File(
        argstr='%s ',
        position=1,
        exists=True,
        mandatory=True,
        desc="The surface to compute on"
    )
    distance=traits.Float(
        mandatory=True,
        argstr='%f',
        position=2,
        desc="Distance in mm to dilate"
    )
    out_file=File(
        name_source=['in_file'],
        name_template="%s.func.gii",
        keep_extension=False,
        argstr='%s ',
        position=3,
        genfile=True,
        desc="The output metric. Autogenerated if not specified."
    )
    nearest=traits.Bool(
        argstr='-nearest',
        position=-1,
        desc="Use the nearest good value instead of a weighted average"
    )
    
    # the next entries are copied with modifications from nipreps
    linear = traits.Bool(
        position=-2,
        argstr="-linear ",
        desc="fill in values with linear interpolation along strongest gradient"
    )
    
    exponent = traits.Float(
        argstr="-exponent %f ",
        position=-3,
        default=6.0,
        desc="exponent n to use in (area / (distance ^ n)) as the "
        "weighting function (default 6)",
    )

    corrected_areas = File(
        argstr="-corrected-areas %s ",
        position=10,
        desc="vertex areas to use instead of computing them from the surface",
    )

    legacy_cutoff = traits.Bool(
        position=-4,
        argstr="-legacy-cutoff ",
        desc="use the v1.3.2 method of choosing how many vertices to "
        "use when calculating the dilated value with weighted method",
    )

class MetricDilateOutputSpec(TraitedSpec):
    out_file=File(
        exists=True,
        desc="The output metric file"
    )

class MetricDilate(wb.WBCommand):
    input_spec = MetricDilateInputSpec
    output_spec = MetricDilateOutputSpec

    _cmd = 'wb_command -metric-dilate'



# Note: this is another quick and dirty implementation. The dirt comes down to
# specifications of suboptions to -var, which can take -select x y -repeat type
# option. If you want to pass something like that implement a Function interface
# that takes your input file name as input and returns a string that includes
# that filename and the subsequent modifiers.
class MetricMathInputSpec(CommandLineInputSpec):
    expression=Str(
        argstr='"%s"',
        position=0,
        desc="a mathematical expression to evaluate"
    )
    out_file=File(
        argstr='%s',
        position=1,
        genfile=True,
        desc="the output gifti file. Autogenerated if not specified."
    )
    in_vars=traits.List(
        traits.Tuple(Str(),
                     traits.Either(File(exists=True),
                                   Str())),
        desc='repeatable - a gifti file to use as a variable',
        argstr='-var "%s" %s...',
        mandatory=True,
        position=2
    )

class MetricMathOutputSpec(TraitedSpec):
    out_file=File(
        exists=True,
        desc="the output metric file"
    )

class MetricMath(wb.WBCommand):
    input_spec = MetricMathInputSpec
    output_spec = MetricMathOutputSpec

    _cmd = 'wb_command -metric-math'


    def _gen_filename(self, name):
        import os

        if name == 'out_file':
            if 'out_file' not in self.inputs.get() or not isdefined(self.inputs.out_file):
                return os.path.join(os.getcwd(), 'metric_math_results.func.gii')
            return self.inputs.out_file

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['out_file'] = self._gen_filename('out_file')

        return outputs