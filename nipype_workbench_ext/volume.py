import os

from nipype.interfaces.workbench import base as wb
from nipype.interfaces.base import (
    traits, 
    File, 
    isdefined, 
    TraitedSpec, 
    CommandLineInputSpec, 
    Str
)
from traits.api import List

# Note: this is another quick and dirty implementation. The dirt comes down to
# specifications of suboptions to -var, which can take -select x y -repeat type
# option. If you want to pass something like that implement a Function interface
# that takes your input file name as input and returns a string that includes
# that filename and the subsequent modifiers.
class VolumeMathInputSpec(CommandLineInputSpec):
    expression=Str(
        argstr='"%s"',
        position=0,
        desc="a mathematical expression to evaluate"
    )
    out_file=File(
        argstr='%s',
        position=1,
        genfile=True,
        desc="the output volume file. Autogenerated if not specified."
    )
    in_vars=traits.List(
        traits.Tuple(Str(),
                     traits.Either(File(exists=True),
                                   Str())),
        desc='repeatable - a volume file to use as a variable',
        argstr='-var "%s" %s...',
        mandatory=True,
        position=2
    )

class VolumeMathOutputSpec(TraitedSpec):
    out_file=File(
        exists=True,
        desc="the output volume file"
    )

class VolumeMath(wb.WBCommand):
    input_spec = VolumeMathInputSpec
    output_spec = VolumeMathOutputSpec

    _cmd = 'wb_command -volume-math'


    def _gen_filename(self, name):
        import os

        if name == 'out_file':
            if 'out_file' not in self.inputs.get() or not isdefined(self.inputs.out_file):
                return os.path.join(os.getcwd(), 'volume_math_results.nii.gz')
            return self.inputs.out_file

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['out_file'] = self._gen_filename('out_file')

        return outputs


# This interface was drafted by chatGPT
class VolumeLabelExportTableInputSpec(CommandLineInputSpec):
    label_in = File(
        exists=True,
        mandatory=True,
        argstr="%s",
        position=0,
        desc="Input CIFTI dlabel.nii file from which to export volume labels.",
    )
    map_id = traits.Either(
        traits.Int(),
        traits.Str(),
        mandatory=True,
        argstr="%s",
        position=1,
        desc="The number or name of the label map to use.",
    )
    table_out = File(
        name_source=["label_in"],
        name_template="%s_label_table.tsv",
        keep_extension=False,
        argstr="%s",
        position=2,
        desc="Output TSV file containing the exported volume label table.",
    )


class VolumeLabelExportTableOutputSpec(TraitedSpec):
    table_out = File(
        exists=True,
        desc="Output TSV file containing the exported volume label table.",
    )


class VolumeLabelExportTable(wb.WBCommand):
    """
    Export a volume label table from a CIFTI dlabel.nii file.

    This interface wraps the Workbench command `-volume-label-export-table`, allowing
    users to export volume label tables directly within Nipype workflows.

    **Examples**

    >>> from nipype_workbench_ext.volume import VolumeLabelExportTable
    >>> export_table = VolumeLabelExportTable()
    >>> export_table.inputs.label_in = 'labels.dlabel.nii'
    >>> export_table.inputs.map_id = 1
    >>> export_table.inputs.table_out = 'label_table.tsv'
    >>> res = export_table.run()  # doctest: +SKIP
    """

    input_spec = VolumeLabelExportTableInputSpec
    output_spec = VolumeLabelExportTableOutputSpec
    _cmd = "wb_command -volume-label-export-table"

    def _format_arg(self, opt, spec, val):
        if opt in ["only_values", "only_names"] and isinstance(val, list):
            # Join list items with commas for the command line
            return ",".join(map(str, val))
        return super(VolumeLabelExportTable, self)._format_arg(opt, spec, val)

    def _list_outputs(self):
        outputs = self.output_spec().get()
        if isdefined(self.inputs.table_out):
            outputs["table_out"] = os.path.abspath(self.inputs.table_out)
        else:
            # Manually strip all known extensions from the input filename
            base = os.path.basename(self.inputs.label_in)
            # Define all possible extensions that need to be stripped
            extensions = ['.dlabel.nii.gz', '.dlabel.nii', '.nii.gz', '.nii']
            for ext in extensions:
                if base.endswith(ext):
                    base = base[:-len(ext)]
                    break
            else:
                # If none of the extensions match, strip the last extension
                base, _ = os.path.splitext(base)
            outputs["table_out"] = os.path.abspath(f"{base}_label_table.tsv")
        return outputs


# this interface was also drafted by chatgpt
class VolumeLabelImportTableInputSpec(CommandLineInputSpec):
    in_file = File(
        exists=True,
        mandatory=True,
        argstr="%s",
        position=0,
        desc="the input volume file.",
    )
    label_list_file = File(
        exists=True,
        mandatory=True,
        argstr="%s",
        position=1,
        desc=(
            "Text file containing the values and names for labels. "
            "Each label is defined by two lines: the label name and "
            "the key with color information."
        ),
    )
    out_file = File(
        name_source=["in_file"],
        name_template="%s_label_volume.nii.gz",
        keep_extension=False,
        argstr="%s",
        position=2,
        desc="Output Workbench label volume.",
    )
    discard_others = traits.Bool(
        argstr="-discard-others",
        position=-1,
        desc=(
            "Set any voxels with values not mentioned in the label list to the "
            "unlabeled label."
        ),
    )
    unlabeled_value = traits.Int(
        argstr="-unlabeled-value %d",
        position=-1,
        desc="Numeric value to interpret as unlabeled (default: 0).",
    )
    subvolume = traits.Either(
        traits.Str(),
        traits.Int(),
        argstr="-subvolume %s",
        position=-1,
        desc="Select a single subvolume to import by number or name.",
    )
    drop_unused_labels = traits.Bool(
        argstr="-drop-unused-labels",
        position=-1,
        desc="Remove any unused label values from the label table.",
    )


class VolumeLabelImportTableOutputSpec(TraitedSpec):
    out_file = File(
        exists=True,
        desc="Output Workbench label volume in CIFTI format.",
    )


class VolumeLabelImportTable(wb.WBCommand):
    """
    Import a label volume into Workbench format from an integer-valued volume file.

    This interface wraps the Workbench command `-volume-label-import`, allowing
    users to import label volumes directly within Nipype workflows.

    **Examples**

    >>> from nipype.interfaces.workbench import VolumeLabelImportTable
    >>> import_table = VolumeLabelImportTable()
    >>> import_table.inputs.in_file = 'input_volume.nii.gz'
    >>> import_table.inputs.label_list_file = 'label_list.tsv'
    >>> import_table.inputs.out_file = 'output_label_volume.nii.gz'
    >>> res = import_table.run()  # doctest: +SKIP

    >>> # Using additional options
    >>> import_table = VolumeLabelImportTable()
    >>> import_table.inputs.in_file = 'input_volume.nii.gz'
    >>> import_table.inputs.label_list_file = 'label_list.tsv'
    >>> import_table.inputs.out_file = 'output_label_volume.nii.gz'
    >>> import_table.inputs.discard_others = True
    >>> import_table.inputs.unlabeled_value = 0
    >>> import_table.inputs.subvolume = 1
    >>> import_table.inputs.drop_unused_labels = True
    >>> res = import_table.run()  # doctest: +SKIP
    """

    input_spec = VolumeLabelImportTableInputSpec
    output_spec = VolumeLabelImportTableOutputSpec
    _cmd = "wb_command -volume-label-import"

    def _format_arg(self, opt, spec, val):
        if opt in ["unlabeled_value"]:
            return str(val)
        elif opt in ["subvolume"]:
            return str(val)
        return super(VolumeLabelImportTable, self)._format_arg(opt, spec, val)

    def _list_outputs(self):
        outputs = self.output_spec().get()
        if isdefined(self.inputs.out_file):
            outputs["output"] = os.path.abspath(self.inputs.out_file)
        else:
            # Manually strip all known extensions from the input filename
            base = os.path.basename(self.inputs.in_file)
            # Define all possible extensions that need to be stripped
            extensions = ['.dlabel.nii.gz', '.dlabel.nii', '.nii.gz', '.nii']
            for ext in extensions:
                if base.endswith(ext):
                    base = base[:-len(ext)]
                    break
            else:
                # If none of the extensions match, strip the last extension
                base, _ = os.path.splitext(base)
            outputs["out_file"] = os.path.abspath(f"{base}_label_volume.nii.gz")
        return outputs